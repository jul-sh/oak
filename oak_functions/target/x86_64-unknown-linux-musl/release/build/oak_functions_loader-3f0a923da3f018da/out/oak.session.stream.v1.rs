#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRequest {
    #[prost(bytes="vec", tag="1")]
    pub body: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingResponse {
    #[prost(bytes="vec", tag="1")]
    pub body: ::prost::alloc::vec::Vec<u8>,
}
# [doc = r" Generated server implementations."] pub mod streaming_session_server { # ! [allow (unused_variables , dead_code , missing_docs , clippy :: let_unit_value ,)] use tonic :: codegen :: * ; # [doc = "Generated trait containing gRPC methods that should be implemented for use with StreamingSessionServer."] # [async_trait] pub trait StreamingSession : Send + Sync + 'static { # [doc = "Server streaming response type for the Stream method."] type StreamStream : futures_core :: Stream < Item = Result < super :: StreamingResponse , tonic :: Status >> + Send + Sync + 'static ; # [doc = " Creates a message stream for session key negotiation and encrypted payload exchange."] # [doc = ""] # [doc = " The created message stream looks as follows:"] # [doc = " - Client->Server: `StreamingRequest` with a serialized `ClientHello` message."] # [doc = " - Server->Client: `StreamingResponse` with a serialized `ServerIdentity` message."] # [doc = " - Client->Server: `StreamingRequest` with a serialized `ClientIdentity` message."] # [doc = " - Client->Server: `StreamingRequest` with a serialized `EncryptedData` message."] # [doc = " - Server->Client: `StreamingResponse` with a serialized `EncryptedData` message."] # [doc = ""] # [doc = " Messages are represented as serialized messages defined in the `remote_attestation::message.rs`"] # [doc = " and `com.google.oak.remote_attestation.Message`."] async fn stream (& self , request : tonic :: Request < tonic :: Streaming < super :: StreamingRequest >>) -> Result < tonic :: Response < Self :: StreamStream > , tonic :: Status > ; } # [derive (Debug)] pub struct StreamingSessionServer < T : StreamingSession > { inner : _Inner < T > , accept_compression_encodings : () , send_compression_encodings : () , } struct _Inner < T > (Arc < T >) ; impl < T : StreamingSession > StreamingSessionServer < T > { pub fn new (inner : T) -> Self { let inner = Arc :: new (inner) ; let inner = _Inner (inner) ; Self { inner , accept_compression_encodings : Default :: default () , send_compression_encodings : Default :: default () , } } pub fn with_interceptor < F > (inner : T , interceptor : F) -> InterceptedService < Self , F > where F : tonic :: service :: Interceptor , { InterceptedService :: new (Self :: new (inner) , interceptor) } } impl < T , B > tonic :: codegen :: Service < http :: Request < B >> for StreamingSessionServer < T > where T : StreamingSession , B : Body + Send + Sync + 'static , B :: Error : Into < StdError > + Send + 'static , { type Response = http :: Response < tonic :: body :: BoxBody > ; type Error = Never ; type Future = BoxFuture < Self :: Response , Self :: Error > ; fn poll_ready (& mut self , _cx : & mut Context < '_ >) -> Poll < Result < () , Self :: Error >> { Poll :: Ready (Ok (())) } fn call (& mut self , req : http :: Request < B >) -> Self :: Future { let inner = self . inner . clone () ; match req . uri () . path () { "/oak.session.stream.v1.StreamingSession/Stream" => { # [allow (non_camel_case_types)] struct StreamSvc < T : StreamingSession > (pub Arc < T >) ; impl < T : StreamingSession > tonic :: server :: StreamingService < super :: StreamingRequest > for StreamSvc < T > { type Response = super :: StreamingResponse ; type ResponseStream = T :: StreamStream ; type Future = BoxFuture < tonic :: Response < Self :: ResponseStream > , tonic :: Status > ; fn call (& mut self , request : tonic :: Request < tonic :: Streaming < super :: StreamingRequest >>) -> Self :: Future { let inner = self . 0 . clone () ; let fut = async move { (* inner) . stream (request) . await } ; Box :: pin (fut) } } let accept_compression_encodings = self . accept_compression_encodings ; let send_compression_encodings = self . send_compression_encodings ; let inner = self . inner . clone () ; let fut = async move { let inner = inner . 0 ; let method = StreamSvc (inner) ; let codec = tonic :: codec :: ProstCodec :: default () ; let mut grpc = tonic :: server :: Grpc :: new (codec) . apply_compression_config (accept_compression_encodings , send_compression_encodings) ; let res = grpc . streaming (method , req) . await ; Ok (res) } ; Box :: pin (fut) } _ => Box :: pin (async move { Ok (http :: Response :: builder () . status (200) . header ("grpc-status" , "12") . header ("content-type" , "application/grpc") . body (empty_body ()) . unwrap ()) }) , } } } impl < T : StreamingSession > Clone for StreamingSessionServer < T > { fn clone (& self) -> Self { let inner = self . inner . clone () ; Self { inner , accept_compression_encodings : self . accept_compression_encodings , send_compression_encodings : self . send_compression_encodings , } } } impl < T : StreamingSession > Clone for _Inner < T > { fn clone (& self) -> Self { Self (self . 0 . clone ()) } } impl < T : std :: fmt :: Debug > std :: fmt :: Debug for _Inner < T > { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , "{:?}" , self . 0) } } impl < T : StreamingSession > tonic :: transport :: NamedService for StreamingSessionServer < T > { const NAME : & 'static str = "oak.session.stream.v1.StreamingSession" ; } }